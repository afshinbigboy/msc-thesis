% !TeX root=../../../main.tex

\chapter{روش پیشنهادی}
%\thispagestyle{empty} 
\section{مقدمه} 
پس از آشنایی با روش‌های پیشین که برای حل مسئله مشابه مورد استفاده قرار گرفته‌اند، حال می‌توانیم به معرفی و تشریح روش‌های پیشنهادی خود برای حل مسئله پیش رو بپردازیم. در این فصل ابتدا داده‌های ورودی مسئله را همراه با فرضیات در نظر گرفته شده بیان می‌کنیم و پس از آن دو روش پیشنهادی متفاوت را بیان خواهیم نمود. در روش اول که به رویکردهای پیشین نزدیک‌تر است با تغییری از جنس روش‌‌های نوین در مراحل میانی به یک روش جدید می‌رسیم که به علت افزایش سرعت همگرایی می‌توان فرض و داده‌های جدیدی را از طریق \lr{CNV} به آن افزود و پاسخ گرفت. اما روش دوم کاملا متفاوت بوده و با رویکردی جدید در حوزه یادگیری ماشین همراه است که به کمک یادگیری تقویتی به حل مسئله مورد نظر می‌پردازد.


\section{معرفی دادگان ورودی}
قبل از وارد شدن به بخش روش‌های پیشنهادی نیاز است تا دادگان ورودی را مشخص و معرفی نماییم تا در قسمت‌های بعدی بتوانیم از نماد‌های معرفی شده در این بخش استفاده نماییم.
\\
دادگان مورد استفاده 

\section{روش پیشنهادی برای مدیریت داده‌های از دست رفته}

در این بخش به معرفی روش پیشنهادی پرداخته خواهد شد. در ابتدا به دلیل وجود داده‌های از دست رفته در پایگاه‌داده‌های مورد استفاده به بررسی و رویکرد حل این مشکل خواهیم پرداخت و در ادامه پس از معرفی روش‌های پیشنهادی برای آن  و  هر کدام از آن‌ها را به طور مفصل شرح خواهیم داد.

همان‌گونه که در داده‌های حقیقی مشاهده شد در پایگاه داده‌های حقیقی ما با اطلاعات از دست رفته مواجه هستیم و به همین دلیل نیز سعی کردیم تا در پایگاه داده مجازی تولید شده نیز به مشابه داده‌های حقیقی، شامل اطلاعات از دست رفته باشد. در این بخش به رویکرد روش محاسبه استاتیک برای مدیریت این داده‌های از دست رفته می‌پردازیم و در بخش بعد به معرفی روشی برای بدست آوردن درخت فیلوژنی پرداخته خواهد شد. همان‌گونه که در ادامه بررسی خواهد شد، این اطلاعات از دست رفته در پایگاه داده‌های مختلف نرخ‌های متفاوتی دارد که تاثیر این تغییرات نیز در روشی پیشنهادی بررسی خواهد شد.

\subsection{روش محاسبه استاتیک}
در این روش قصد داریم تا به یک‌باره بتوانیم مقادیر مناسب برای داده‌هایی که از دست رفته‌اند را تخمین بزنیم. در این روش باید توجه شود که ما لزوما به دنبال جایگذاری مقدار از دست رفته با مقدار درست واقعی نیستیم. اگرچه چنین بیانی در نگاه اول ممکن است تعجب‌آور باشد اما با دقت بیشتر متوجه خواهیم شد که ما در آینده برای خطاهای موجود در پایگاه داده مدل‌سازی‌های محدودی داریم. مدل‌هایی که بهترین آن‌ها نیز ممکن است با واقعیت نویز افزوده شده به دادگان متفاوت باشد. در نتیجه اگر مطمئن بودیم که تمام داده‌هایی که موجود می‌باشند بدون خطا هستند در آن صورت ما نیز به دنبال یافتن جایگذاری با مقدار واقعی بودیم اما در حال حاضر که درصدی از داده‌های در دسترس خود همراه با خطا می‌باشند، ما به دنبال جایگذاری‌ای هستیم که بتواند در مجموع با مدل‌سازی خطایی که در نظر می‌گیریم بیشترین سازگاری را داشته باشد کما اینکه ممکن است در حقیقت جایگزاری اشتباهی انجام داده باشیم. حال با توجه به توضیحی که بیان شد به تشریح این روش می‌پردازیم.

با توجه به فرض مدل مکان‌های بی‌نهایت می‌دانیم که جهش‌های اتفاق افتاده در والد در تمامی نسل‌های آینده باقی خواهد ماند. بنابرین اگر تمامی جهش‌های نمونه (سلول) $a$ در نمونه‌ای دیگر مانند $b$ قرار داشته باشد، بنابرین می‌توان نتیجه گرفت که $a$ یکی از اجداد $b$ خواهد بود. همین فرضیه هسته اصلی روش پیشنهادی درنظر گرفته شده را تشکیل می‌دهد. بنابرین اگر جهش $i$ در سلول $a$ از دست رفته است، با توجه به اینکه آن جهش در سلول $b$ چه وضعیتی دارد می‌توان تصمیم‌گیری کرد. اگر $b(i)=0$ باشد، در این صورت $a(i)$ حتما باید $0$ باشد وگرنه فرض اولیه مدل مکان‌های بی‌نهایت نقض خواهد شد. اما اگر $b(i)=1$ باشد، آنگاه نتیجه خاصی نمی‌توان گرفت و باید به دنبال نمونه والد $a$ یعنی نمونه $d$ باشیم. حال اگر $d(i)=1$ باشد، آنگاه $a(i)$ حتما باید $1$ باشد. اما اگر $d(i)=0$ بود آنگاه انتخاب هر مقداری برای $a(i)$ تقریبا آزاد خواهد بود زیرا با فرض اولیه تناقضی ندارد و اینکه ساختار فیلوژنی را تغییر نمی‌دهد. اما از آنجایی که  خود داده‌های در دسترس شامل خطا می‌باشند و هر نمونه‌ای که حاوی اطلاعات از دست رفته است لزوما یک نواده یا یک والد ندارد، مجموعه‌ای از سلول‌های فرزند یا والد خواهند بود که متناسب با پارمترهای خطایی که در نظر می‌گیریم و فاصله ژنی‌ای که دارند می‌توانند در تصمیم‌گیری تاثیرگزار باشند. صورت دقیق‌تر توضیحات داده شده را می‌توان به صورت فرمولی که در ادامه آمده است به نمایش درآورد.
\\
در ابتدا تابعی به نام $F_s(D_{ij})$ تعریف می‌کنیم که به نوعی با توجه به ارزشی که به سلول‌های نواده شده از سلول $j$ می‌دهد سعی دارد تا اطمینان $0$ بودن داده از دست رفته $D_{ij}$ را بیان کند.
\\
برای محاسبه این تابع می‌دانیم که ابتدا سلول‌های مختلف با توجه به احتمال نواده بودنشان باید رتبه‌بندی شوند و وزن بگیرند. پس از آن  هر سلول متناسب با ارزش تاثیرگزاری خود می‌تواند در مورد جایگاه جهش $i$ برای سلول $j$ نظر دهد.
\begin{equation}
	F_s(D_{ij}) = \sum_{n \in \mathcal{N}}  (1-D_{mj})  \prod_{m=1}^{M} W(D_{mn}, D_{mj})
	\label{eq:F_s_simple}
\end{equation}

در فرمول \ref{eq:F_s_simple} مجموعه $\mathcal{N}$ برابر با مجموعه سلول‌های متمایز از هم است. زیرا که در بسیاری از پایگاه‌داده‌ها از یک نمونه سلول ممکن است چندین نمونه وجود داشته باشد که وجود آن‌ها باعث بایس در محاسبات ما خواهد شد. همچنین تابع $W_s(c,p)$ به ارزش‌دهی جهش $c$ در برابر $p$ به عنوان نواده بودن می‌پردازد که در فرمول \ref{eq:W_simple} تعریف شده است.
\begin{equation}
	W(c, p) = 
	\begin{cases}
		1 	       &\qquad \text{\lr{if}} \quad c=1, p=1 \\
		1-\xi   &\qquad \text{\lr{if}} \quad c=1, p=0 \\
		0 		  &\qquad \text{\lr{if}} \quad c=0, p=1 \\
		1 	 	  &\qquad \text{\lr{if}} \quad c=0, p=0
	\end{cases}
	\label{eq:W_simple}
\end{equation}
مقدار $\xi$ عددی بین $(0,1)$ است که پارامتری در جهت میزان ارزش‌دهی به نوادگان با فواصل مختلف می‌باشد. هرچه این عدد بزرگتر باشد به معنی کم‌ارزش‌تر شدن نوادگان با فواصل بیشتر است و بلاعکس.
\\
به همین صورت برای اولاد سلول $j$ نیز می‌توان مشابه حالت قبل عمل کرد که روابط آن به صورت فرمول‌ \ref{eq:F_a_simple} خواهد شد.
\begin{equation}
	F_a(D_{ij}) = \sum_{n \in \mathcal{N}}  D_{mj}  \prod_{m=1}^{M} W(D_{mj}, D_{mn})
	\label{eq:F_a_simple}
\end{equation}
حال دو نکته در استفاده از روابط بالا باقی خواهد ماند. 
\\
نکته اول وجود داده‌های دیگر از دست رفته در محاسبه توابع است که به دو صورت می‌توان با آن‌ها برخورد  نمود. رویکرد اول این است که در آن‌جایگاه ژنی از محاسبه آن خود داری شود و رویکرد دوم استفاده از از مقدار $0.5$ یا فراوانی نسبی آن جهش در محسبات است که ما رویکرد اول را در این گزارش استفاده خواهیم کرد.
\\
نکته دوم وجود خطا در داده‌هاست. برای مدیریت این مشکل می‌توان با مدل‌سازی خطا که به صورت فرمول \ref{eq:P_alpha_beta} بیان می‌شود، برخورد کرد.
\begin{equation}
	\begin{aligned}
		&P(D_{ij}=1|E_{ij}=0)=\alpha, &\qquad P(D_{ij}=0|E_{ij}=0)=1-\alpha \\ &P(D_{ij}=0|E_{ij}=1)=\beta, &\qquad P(D_{ij}=1|E_{ij}=1)=1-\beta
	\end{aligned}
	\label{eq:P_alpha_beta}
\end{equation}
پس از تعریف مدل‌سازی خطا می‌توان روابط قبلی را مجددا به صورتی که در ادامه آمده است بازنویسی کرد.
\begin{equation}
	\begin{aligned}
		W_e(c,p) = \sum_{i,j \in \{0,1\}} P(c|E_c=i)P(p|E_p=j)W(i,j)
	\end{aligned}
	\label{eq:W_e}
\end{equation}
که در این صورت توابع $F_p$ و $F_a$ نیز به صورت زیر همراه با مدل‌سازی خطا بازتعریف خواهند شد.
\begin{equation}
	\begin{aligned}
		\hat{F}_s(D_{ij}) &= \sum_{n \in \mathcal{N}}  [1-D_{mj}(1-\alpha)]  \prod_{m=1}^{M} W_e(D_{mn}, D_{mj}) \\
		\hat{F}_a(D_{ij}) &= \sum_{n \in \mathcal{N}}  D_{mj}(1-\beta)  \prod_{m=1}^{M} W_e(D_{mj}, D_{mn})
	\end{aligned}
	\label{eq:F_all_final}
\end{equation}
حال پس از محاسبه مقادیر $\hat{F}_s$ و $\hat{F}_a$ می‌توان در مورد داده نامعلوم $D_{ij}$  به صورت فرمول \ref{eq:F_to_D} تصمیم گرفت.
\begin{equation}
	D_{ij} = \begin{cases}
		0 \qquad \text{\lr{if}} \quad \hat{F}_s \ge \hat{F}_a \\
		1 \qquad \text{\lr{if}} \quad \hat{F}_s < \hat{F}_a
	\end{cases}
	\label{eq:F_to_D}
\end{equation}
همچنین با کمی دقت در فرمول‌بندی انجام شده اگر برای تمام $i,j$های ماتریس $D$ این مقادیر توابع $\hat{F}$ محاسبه شوند، خود می‌توانند معیاری برای ارزیابی پایگاه‌داده در دسترس و احتمال درستی فرض مدل مکان‌های بی‌نهایت باشند.

%	\subsection{روش بیشینه درست‌نمایی}
%	در این روش هر کدام از جهش‌های نامشخص و از دست رفته با توجه به بیشینه شدن درست‌نمایی مشخص خواهند شد. در واقع در این رویکرد به دو صورت می‌تواند انجام شود. نخست آنکه برحسب یک مدل از پیش تعریف‌شده،


\subsubsection{تصادفی}
پر کردن کاملا تصادفی میس‌ها


	
	\begin{table}[ht]
		\caption{اندیس‌های به کار رفته در روابط روش پیشنهادی اول}
		\label{tab:firstpmIndices}
		\centering
		\onehalfspacing
		\begin{tabularx}{0.9\textwidth}{|r|X|}
			\hline
			$D$	& ماتریس داده نویزی در دسترس که مقادیر $0$ و $1$ در آن قرار دارد \\
			\hline
			$E$	& ماتریس داده حقیقی بدون نویز که به دنبال آن هستیم \\
			\hline
			$T$	& درخت فیلوژنی جهش‌ها \\
			\hline
			$\sigma$	& بردار انتصابات \\
			\hline
			$X_T$	& ماتریس متناظر درخت $T$ \\
			\hline
			$N$		& تعداد سلول‌های نمونه \\
			\hline
			$M$	& تعداد جهش‌ها \\
			\hline
			$\alpha$	&  نرخ خطای \gls{falsepositive} \\
			\hline
			$\beta$	& نرخ خطای \gls{falsenegative} \\
			\hline
		\end{tabularx}
	\end{table}
	
	\begin{table}[ht]
		\caption{پارامترهای مدل ریاضی}
		\label{tab:modelParameters}
		\centering
		\onehalfspacing
		\begin{tabularx}{0.9\textwidth}{|r|X|}
			\hline
			$t_{ik}$			& زمان خدمت‌دهی به بیمار در مرحله $k$ام \\
			\hline
			$\tilde{t}_{ik}$	& زمان فاری خدمت‌دهی به بیمار در محله $k$ام \\
			\hline
			$t_{ik}^p$			& مقدار بدبینانه (حداکثر) برای زمان خدمت‌دهی به بیمار در مرحله $k$ام \\
			\hline
			$t_{ik}^m$			& محتمل‌ترین مقدار برای زمان خدمت‌دهی به بیمار در مرحله $k$ام \\
			\hline
			$t_{ik}^o$			& مقدار خوشبینانه (حداقل) برای زمان خدمت‌دهی به بیمار در مرحله $k$ام \\
			\hline
		\end{tabularx}
	\end{table}
	
	\begin{table}[ht]
		\caption{متغیرهای مدل ریاضی}
		\label{tab:modelVariables}
		\centering
		\onehalfspacing
		\begin{tabularx}{0.9\textwidth}{|r|X|}
			\hline
			$X_{ild_{k}}$	& متغیر صفر-یک تخصیص بیمار به تخت/اتاق عمل\\
			\hline
			$S_{ild_{k}}$	& زمان شروع خدمت‌دهی به بیمار \\
			\hline
			$Y_{ijkl_{k}}$	& متغیر صفر-یک توالی بیماران \\
			\hline
			$V_{ni}$		& متغیر صفر-یک تخصیص جراح به بیمار‍‍ \\
			\hline
		\end{tabularx}
	\end{table}
	



\section{روش پیشنهادی اول (درخت‌بازی)}

\subsection{پیش‌پردازش}
قبل از شروع باید بر روی داده‌ها یک پیش‌پردازش اعمال کنیم که وابسته به سیاست درنظر گفته شده می‌تواند باعث تغییر در پاسخ نهایی نیز شود. به این منظور داده‌هایی که \lr{miss} شده‌اند با روش‌های زیر ‌می‌تواند برای ورود به مرحله بعد تخمین زده شود.
